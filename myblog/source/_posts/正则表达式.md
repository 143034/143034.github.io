---
title: 正则表达式
date: 2020-04-22 14:21:13
categories:
- python
tags: 
- 正则表达式
---


![正则](/images/zhengze.png)

# 数量词的贪婪模式与非贪婪模式 #


> Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab*”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab*?”，将找到”a”。
注：我们一般使用非贪婪模式来提取。

# 反斜杠问题 #

> 正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\\\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。


> Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\\”表示。同样，匹配一个数字的”\\d”可以写成r”\d”。有了原生字符串，妈妈也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。
# python的re函数 #

## （1）re.match(pattern, string[, flags])开头匹配 ##



> 这个方法将会从开头开始尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。
## （2）re.search(pattern, string[, flags]) ##


> search方法与match方法类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配
## （3）re.split(pattern, string[, maxsplit]) ##


> 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。
## （4）re.findall(pattern, string[, flags]) ##


> 搜索string，以列表形式返回全部能匹配的子串。
## （5）re.finditer(pattern, string[, flags]) ##


> 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。、
## （6）re.sub(pattern, repl, string[, count]) ##


> 使用repl替换string中每一个匹配的子串后返回替换后的字符串。
