---
title: 串口配置函数
date: 2020-07-28 10:41:20
tags:
- stm32
categories:
- 单片机
- stm32

---


# 常用的串口相关寄存器 #


**USART_SR状态寄存器**

> FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);

![状态寄存器USART_SR](/images/单片机/stm32/串口/状态寄存器USART_SR.png)

**USART_DR数据寄存器**

> void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);

> uint16_t USART_ReceiveData(USART_TypeDef* USARTx);

![数据寄存器USART_DR](/images/单片机/stm32/串口/数据寄存器USART_DR.png)


**USART_BRR波特率寄存器** 

> void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);

![波特率寄存器USART_BRR](/images/单片机/stm32/串口/波特率寄存器USART_BRR.png)


## 串口操作相关库函数（省略入口参数）： ##

	void USART_Init(); //串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能
	void USART_Cmd();//使能串口
	void USART_ITConfig();//使能相关中断
	
	void USART_SendData();//发送数据到串口，DR
	uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据
	
	FlagStatus USART_GetFlagStatus();//获取状态标志位
	void USART_ClearFlag();//清除状态标志位
	ITStatus USART_GetITStatus();//获取中断状态标志位
	void USART_ClearITPendingBit();//清除中断状态标志位

## 波特率计算方法 ##

![波特率计算方法1](/images/单片机/stm32/串口/波特率计算方法1.png)

![波特率计算方法2](/images/单片机/stm32/串口/波特率计算方法2.png)




# 串口配置的一般步骤 #

**1、串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd();**

**2、串口复位:USART_DeInit(); 这一步不是必须的**

**3、GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP**

**4、串口参数初始化：USART_Init();**

**5、开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）**
      NVIC_Init();
      USART_ITConfig();

**6、使能串口:USART_Cmd();**

**7、编写中断处理函数：USARTx_IRQHandler();**

**8、串口数据收发：**

	void USART_SendData();//发送数据到串口，DR
	uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据

**9、串口传输状态获取：**

	FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
	void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);


# 代码: #


	void My_USART1_Init(void)
	{
		GPIO_InitTypeDef GPIO_InitStrue;
		USART_InitTypeDef USART_InitStrue;
		NVIC_InitTypeDef NVIC_InitStrue;
		
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//¢Ù
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);
		
		GPIO_InitStrue.GPIO_Mode=GPIO_Mode_AF_PP;//推挽复用输出
		GPIO_InitStrue.GPIO_Pin=GPIO_Pin_9;
		GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz;
	    GPIO_Init(GPIOA,&GPIO_InitStrue);//¢Ú
		
		GPIO_InitStrue.GPIO_Mode=GPIO_Mode_IN_FLOATING;//浮空输入
		GPIO_InitStrue.GPIO_Pin=GPIO_Pin_10;
		GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz;
	    GPIO_Init(GPIOA,&GPIO_InitStrue);//¢Ú
		
		USART_InitStrue.USART_BaudRate=115200;//波特率
		USART_InitStrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;//不适用硬件流
		USART_InitStrue.USART_Mode=USART_Mode_Tx|USART_Mode_Rx;
		USART_InitStrue.USART_Parity=USART_Parity_No;//关闭奇偶校验
		USART_InitStrue.USART_StopBits=USART_StopBits_1;//停止位
		USART_InitStrue.USART_WordLength=USART_WordLength_8b;//数据位
		
		USART_Init(USART1,&USART_InitStrue);
		
		USART_Cmd(USART1,ENABLE);//使能串口
		
		USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);//开启接收中断
		
		NVIC_InitStrue.NVIC_IRQChannel=USART1_IRQn;
		NVIC_InitStrue.NVIC_IRQChannelCmd=ENABLE;
		NVIC_InitStrue.NVIC_IRQChannelPreemptionPriority=1;
		NVIC_InitStrue.NVIC_IRQChannelSubPriority=1;
		NVIC_Init(&NVIC_InitStrue);
		
		
	}
	
	void USART1_IRQHandler(void)//中断服务函数
	{
		u8 res;
		 if(USART_GetITStatus(USART1,USART_IT_RXNE))
	 {
	     res= USART_ReceiveData(USART1); 
	     USART_SendData(USART1,res);   
	  }
	}
	int main(void)
	 {	
	  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
		My_USART1_Init();
		 while(1);
		 
	 }