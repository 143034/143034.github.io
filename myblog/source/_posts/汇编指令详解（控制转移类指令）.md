---
title: 汇编指令详解（控制转移类指令）
date: 2020-09-19 12:17:14
tags:
- 汇编
categories:
- 单片机
- 汇编语言

---

# 一、控制转移类指令 #

### 1.1、无条件转移类指令 ###

#### 1.短转移类指令 ####

**AJMP       addr11**

 

#### 2.长转移类指令 ####

**LJMP       addr16**

 

#### 3.相对转移指令 ####

**SJMP       rel**

 

上面的三条指令，如果要仔细分析的话，区别较大，但初学时，可不理会这么多，统统理解成：JMP标号，也就是跳转到一个标号处。事实上，LJMP标号，在前面的例程中我们已接触过，并且也知道如何来使用了。而AJMP和SJMP也是一样。那么他们的区别何在呢？在于跳转的范围不一样。好比跳远，LJMP一下就能跳64K这么远（当然近了更没关系了）。而AJMP最多只能跳2K距离，而SJMP则最多只能跳256这么远。原则上，所有用SJMP或AJMP的地方都可以用LJMP来替代。因此在初学时，需要跳转时可以全用LJMP，除了一个场合。什么场合呢？先了解一下AJMP，AJMP是一条双字节指令，也就说这条指令本身占用存储器（ROM）的两个单元。而LJMP则是三字节指令，即这条指令占用存储器（ROM）的三个单元。下面是第四条跳转指令。

 

### 1.2、间接转移指令 ###

**JMP         @A+DPTR**

这条指令的用途也是跳转，转到什么地方去呢？这可不能由标号简单地决定了。让我们从一个实际的例子入手吧。

MOV    DPTR，#TAB       ;将TAB所代表的地址送入DPTR
	
MOV    A，R0                  ;从R0中取数（详见下面说明）
	
MOV    B，#2                        
	
MUL    A，B           ;A中的值乘2（详见下面的说明）
	
JMP    A，@A+DPTR      ;跳转
	
TAB:      AJMP     S1          ;跳转表格
	
AJMP     S2
	
AJMP     S3

 
应用背景介绍：在单片机开发中，经常要用到键盘，见上面的9个按键的键盘。我们的要求是：当按下功能键A………..G时去完成不同的功能。这用程序设计的语言来表达的话，就是：按下不同的键去执行不同的程序段，以完成不同的功能。怎么样来实现呢？

前面的程序读入的是按键的值，如按下'A'键后获得的键值是0，按下'B'键后获得的值是'1'等等，然后根据不同的值进行跳转，如键值为0就转到S1执行，为1就转到S2执行。。。。如何来实现这一功能呢？

先从程序的下面看起，是若干个AJMP语句，这若干个AJMP语句最后在存储器中是这样存放的，也就是每个AJMP语句都占用了两个存储器的空间，并且是连续存放的。而AJMP S1存放的地址是TAB，到底TAB等于多少，我们不需要知道，把它留给汇编程序来算好了。

下面我们来看这段程序的执行过程：第一句MOV DPTR，#TAB执行完了之后，DPTR中的值就是TAB，第二句是MOV A，R0，我们假设R0是由按键处理程序获得的键值，比如按下A键，R0中的值是0，按下B键，R0中的值是1，以此类推，现在我们假设按下的是B键，则执行完第二条指令后，A中的值就是1。并且按我们的分析，按下B后应当执行S2这段程序，让我们来看一看是否是这样呢？第三条、第四条指令是将A中的值乘2，即执行完第4条指令后A中的值是2。下面就执行JMP @A+DPTR了，现在DPTR中的值是TAB，而A+DPTR后就是TAB+2，因此，执行此句程序后，将会跳到TAB+2这个地址继续执行。看一看在TAB+2这个地址里面放的是什么？就是AJMP    S2这条指令。因此，马上又执行AJMP              S2指令，程序将跳到S2处往下执行，这与我们的要求相符合。

请大家自行分析按下键“A”、“C”、“D”……之后的情况。

这样我们用JMP     @A+DPTR就实现了按下一键跳到相应的程序段去执行的这样一个要求。再问大家一个问题，为什么取得键值后要乘2？如果例程下面的所有指令换成LJMP，即：

LJMP      S1,LJMP        S2……这段程序还能正确地执行吗？如果不能，应该怎么改？

 

### 1.3、条件转移指令 ###

**条件转移指令是指在满足一定条件时进行相对转移。** 

#### 1.31、判A内容是否为0转移指令 ####

**JZ rel**
	
**JNZ rel**
	
第一指令的功能是：如果(A)=0，则转移，否则顺序执行（执行本指令的下一条指令）。转移到什么地方去呢？如果按照传统的方法，就要算偏移量，很麻烦，好在现在我们可以借助于机器汇编了。因此这第指令我们可以这样理解：JZ 标号。即转移到标号处。下面举一例说明：
	
MOV A,R0
	
JZ L1
	
MOV R1,#00H
	
AJMP L2
	
L1: MOV R1,#0FFH
	
L2: SJMP L2
	
END
	
在执行上面这段程序前如果R0中的值是0的话，就转移到L1执行，因此最终的执行结果是R1中的值为0FFH。而如果R0中的值不等于0，则顺序执行，也就是执行 MOV R1，#00H指令。最终的执行结果是R1中的值等于0。
	
第一条指令的功能清楚了，第二条当然就好理解了，如果A中的值不等于0，就转移。把上面的那个例子中的JZ改成JNZ试试吧，看看程序执行的结果是什么?

 

#### 1.32、比较转移指令 ####

**CJNE A,#data,rel**

**CJNE A,direct,rel**

**CJNE Rn,#data,rel**

**CJNE @Ri,#data,rel**
	
第一条指令的功能是将A中的值和立即数data比较，如果两者相等，就顺序执行（执行本指令的下一条指令），如果不相等，就转移，同样地，我们可以将rel理解成标号，即：CJNE A，#data,标号。这样利用这条指令，我们就可以判断两数是否相等，这在很多场合是非常有用的。但有时还想得知两数比较之后哪个大，哪个小，本条指令也具有这样的功能，如果两数不相等，则CPU还会反映出哪个数大，哪个数小，这是用CY（进位位）来实现的。如果前面的数（A中的）大，则CY=0，否则CY=1，因此在程序转移后再次利用CY就可判断出A中的数比data大还是小了。
	
例：
	
MOV A,R0
	
CJNE A,#10H,L1
	
MOV R1,#0FFH
	
AJMP L3
	
L1: JC L2
	
MOV R1,#0AAH
	
AJMP L3
	
L2: MOV R1,#0FFH
	
L3: SJMP L3
	
上面的程序中有一条指令我们还没学过，即JC，这条指令的原型是JC rel,作用和上面的JZ类似，但是它是判CY是0，还是1进行转移，如果CY=1，则转移到JC后面的标号处执行，如果CY=0则顺序执行（执行它的下面一条指令）。

分析一下上面的程序，如果（A）=10H，则顺序执行，即R1=0。如果（A）不等于10H，则转到L1处继续执行，在L1处，再次进行判断，如果（A）>10H，则CY=1，将顺序执行，即执行MOV R1，#0AAH指令，而如果（A）<10H，则将转移到L2处指行，即执行MOV R1，#0FFH指令。因此最终结果是：本程序执行前，如果（R0）=10H，则（R1）=00H，如果（R0）>10H，则（R1）=0AAH，如果（R0）<10H，则（R1）=0FFH。

弄懂了这条指令，其它的几条就类似了，第二条是把A当中的值和直接地址中的值比较，第三条则是将直接地址中的值和立即数比较，第四条是将间址寻址得到的数和立即数比较，这里就不详谈了，下面给出几个相应的例子。
	
CJNE A,10H ;把A中的值和10H中的值比较（注意和上题的区别）
	
CJNE 10H，#35H ;把10H中的值和35H中的值比较
	
CJNE @R0,#35H ;把R0中的值作为地址，从此地址中取数并和35H比较

 

### 1.33、循环转移指令 ###

**DJNZ Rn,rel**

**DJNZ direct,rel**

第一条指令在前面的例子中有详细的分析，这里就不多谈了。第二条指令，只是将Rn改成直接地址，其它一样，也不多说了，给一个例子。

DJNZ 10H，LOOP

 

调用与返回指令

（1）主程序与子程序 在前面的灯的实验中，我们已用到过了子程序，只是我们并没有明确地介绍。子程序是干什么用的，为什么要用子程序技术呢？举个例子，我们数据老师布置了10道算术题，经过观察，每一道题中都包含一个（3*5+2）*3的运算，我们可以有两种选择，第一种，每做一道题，都把这个算式算一遍，第二种选择，我们可以先把这个结果算出来，也就是51，放在一边，然后要用到这个算式时就将51代进去。这两种方法哪种更好呢？不必多言。设计程序时也是这样，有时一个功能会在程序的不同地方反复使用，我们就可以把这个功能做成一段程序，每次需要用到这个功能时就“调用”一下。

 

（2）调用及回过程：主程序调用了子程序，子程序执行完之后必须再回到主程序继续执行，不能“一去不回头”，那么回到什么地方呢？是回到调用子程序的下面一条指令继续执行（当然啦，要是还回到这条指令，不又要再调用子程序了吗？那可就没完没了了……）。 
