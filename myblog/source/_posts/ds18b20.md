---
title: ds18b20
date: 2020-10-22 14:39:41
tags: 
- 52
categories:
- 单片机
- 52单片机

---


# 一、介绍 #

### 1.1、引脚介绍 ###

![ds18b20图和引脚](/images/单片机/52单片机/ds18b20/ds18b20图和引脚.png)

### 1.2、内部介绍 ###

![内部单元介绍](/images/单片机/52单片机/ds18b20/内部单元介绍.png)

**DS18B20的内部有64位的ROM单元和9字节的暂存器单元。64位ROM包含了DS18B20唯一的序列号（唯一的名字）。**

# 二、暂存器 #

### 2.1、暂存器介绍 ###

![暂存器介绍](/images/单片机/52单片机/ds18b20/暂存器介绍.png)

**内部9个字节的暂存单元**

1. 字节 0~1 是转换好的温度。
2. 字节 2~3 是用户用来设置最高报警和最低报警值。这个可以用软件来实现。
3. 字节 4 是用来配置转换精度，9~12 位。
4. 字节 5~8 就不用看了。

### 2.2、数据手册 ###

![温度数据关系](/images/单片机/52单片机/ds18b20/温度数据关系.png)


### 2.3、字节0~1（转换好的温度） ###


![温度寄存器](/images/单片机/52单片机/ds18b20/温度寄存器.png)


**DS18B20 的温度操作是使用 16 位，也就是说分辨率是 0.0625。BIT15~BIT11 是符号位 ，为了就是表示转换的值是正数还是负数。**

**要求出正数的十进制值，必须将读取到的 LSB 字节，MSB 字节进行整合处理，然后乘以 0.0625 即可。负数时判断 BIT11~15 是否是 1，然后人为置一负数标志。**




### 2.4、字节2~3TH和TL配置 ###

TH 与 TL 就是所谓的温度最高界限，和温度最低界限的配置。其实这些可以使用软件来试验，所以就无视了。


### 2.5、字节4配置寄存器 ###


![配置寄存器](/images/单片机/52单片机/ds18b20/配置寄存器.png)


BIT7 出厂的时候就已经设置为 0，用户不建议去更改。而 R1 与 R0 位组合了四个不同的转换精度，00 为 9 位转换精度而转换时间是 93.75ms，01 为 10 位转换精度而转换时间是 187.5ms，10 为 11 位转换精度而转换时间是 375ms，11为 12 位转换精度而转换时间是 750ms（默认）。该寄存器还是留默认的好，毕竟转换精度表示了转换的质量。



### 2.6、字节5~7,8保留位，CRC(不使用) ###



# 三、单片机访问 #

### 3.1、步骤 ###

单片机通过一线总线访问DS18B20 的话，需要经过以下几个步骤：

1. **DS18B20 复位。**
2. **执行 ROM 指令**。
3. **执行 DS18B20 功能指令（RAM 指令）。**


DS18B20 复位，在某种意义上就是一次访问 DS18B20 的开始，或者可说成是开始信号。

ROM 指令，也就是访问，搜索，匹配，DS18B20 个别的 64 位序列号的动作。在单点情况下，可以直接跳过 ROM 指令。而跳过 ROM 指令的字节是 0xCC。

DS18B20 功能指令（很多）

0x44：开始转换温度。转换好的温度会储存到暂存器字节 0 和 1。
0xEE：读暂存指令。读暂存指令，会从暂存器 0 到 9，一个一个字节读取，如果要停止的话，必须写下 DS18B20 复位。


### 3.2、初始化 ###

![复位图](/images/单片机/52单片机/ds18b20/复位图.png)


**DS18B20 的复位时序如下**

1. 单片机拉低总线 480us~950us, 然后释放总线（拉高电平）。
2. 这时 DS18B20 会拉低信号，大约 60~240us表示应答。
3. DS18B20 拉低电平的 60~240us 之间，单片机读取总线的电平，如果是低电平，那么表示复位成功。
4. DS18B20 拉低电平 60~240us 之后，会释放总线。


### 3.3、写逻辑0与1时序 ###


![写逻辑0与1](/images/单片机/52单片机/ds18b20/写逻辑0与1.png)

**DS18B20 写逻辑 0 的步骤如下**

1. 单片机拉低电平大约 10~15us,。
2. 单片机持续拉低电平大约 20~45us 的时间。
3. 释放总线



**DS18B20 写逻辑 1 的步骤如下**

1. 单片机拉低电平大约 10~15us,。
2. 单片机拉高电平大约 20~45us 的时间。
3. 释放总线




### 3.4、读逻辑0与1时序 ###



![读逻辑0与1](/images/单片机/52单片机/ds18b20/读逻辑0与1.png)


**DS18B20 读逻辑 0 的步骤如下**

1. 在读取的时候单片机拉低电平大约 1us
2. 单片机释放总线，然后读取总线电平。
3. 这时候 DS18B20 会拉低电平。
4. 读取电平过后，延迟大约 40~45 微妙



**DS18B20 读逻辑 1 的步骤如下**

1. 在读取的时候单片机拉低电平大约 1us
2. 单片机释放总线，然后读取总线电平。
3. 这时候 DS18B20 会拉高电平。
4. 读取电平过后，延迟大约 40~45 微妙


**如果要读或者写一个字节，就要重复以上的步骤八次**





# 四、DS18B20 温度读取函数参考步骤 #

### 4.1、DS18B20 开始转换 ###


1. DS18B20 复位。
2. 写入跳过 ROM 的字节命令，0xCC。
3. 写入开始转换的功能命令，0x44。
4. 延迟大约 750~900 毫秒

### 4.2、DS18B20 读暂存数据 ###

1. DS18B20 复位。
2. 写入跳过 ROM 的字节命令，0xCC。
3. 写入读暂存的功能命令，0xee。
4. 读入第 0 个字节 LS Byte，转换结果的低八位。
5. 读入第 1 个字节 MS Byte，转换结果的高八位。
6. DS18B20 复位，表示读取暂存结束。

### 4.3、数据求出十进制 ###

1. 整合 LS Byte 和 MS Byte 的数据
2. 判断是否为正负数（可选）
3. 求得十进制值。正数乘以 0.0625，一位小数点乘以 0.625，二位小数点乘以 6.25。
4. 十进制的“个位”求出。


# 五、代码 #

**ds18b20.h**
	
	#ifndef __ds_18b20_H
	
	
	#define __ds_18b20_H
	
	#include "reg52.h"
	#include "lcd1602.h"
	
	#define uchar unsigned char 
	#define uint unsigned int 
	unsigned char reset_ds18b20();
	unsigned char read_bit_ds18b20();
	void write_bit_ds18b20(uchar dat);
	void write_byte_ds18b20(uchar dat);
	unsigned char read_byte_ds18b20();
	int read_temp_ds18b20();
	
	void delay720us(void);
	void delay15us(void);
	void delay45us(void);
	void delay(uint z);
	void delay_ds18b20(unsigned int time);
	void write_bit_ds18b20(unsigned char dat);
	
	#endif


**ds18b20.c**
		
		#include "ds18b20.h"
		#include "intrins.h"
		
		sbit DQ = P2^2;
		 
		
		unsigned char reset_ds18b20()
		{
		   uchar presence;
		   DQ=0;
		   delay_ds18b20(29);      //延时480 - 960  us
		   DQ=1;						  
		   delay_ds18b20(3);      //延时 15 - 60   us
		   presence=DQ;
		   delay_ds18b20(25);	  //延时 60 - 240  us
		   return(presence);
		
		}
		
		
		 unsigned char read_bit_ds18b20()
		{
			uchar i;
			DQ=1;
			delay_ds18b20(1);
			DQ=0;
			//delay(1);    //延时 15us  也可以不延时
			DQ=1;
			//delay(3);	 //延时 1 - ∞  us
			for(i=0;i<3;i++);
			return(DQ);
		} 
		void write_bit_ds18b20(uchar dat)
		{
			DQ=0;        //置0 无需延时
			if(dat==1)
			  DQ=1;
			delay_ds18b20(1);	 //延时 60 - 120  us
			DQ=1;
			delay_ds18b20(1);	 //延时 1 - ∞  us
		}
		
		
		
		void write_byte_ds18b20(uchar dat)
		{
		     uchar i,j;
			 for(i=0;i<8;i++)
			 {
			     j=((dat>>i)&0x01);
				 write_bit_ds18b20(j);
				 //delay(1);      //延时 1 - ∞  us
			 }
		
		
		}  
		
		
		unsigned char read_byte_ds18b20()
		{
			uchar dat=0;
			uchar i;
			for(i=0;i<8;i++)
			 {
			   if(read_bit_ds18b20())
			     dat|=0x01<<i;
			   //delay(1);	   //延时 1 - ∞  us
			 
			 }
			 return(dat); 	  
		}
		
		
		 
		int read_temp_ds18b20()
		{
		   uchar templ=0,temph=0;
		   int temp=0;
		   reset_ds18b20();//复位
		   write_byte_ds18b20(0xcc); //跳过ROM
		   write_byte_ds18b20(0x44); //跳过温度采集
		   delay_ds18b20(10);     //750ms
		   reset_ds18b20();
		   write_byte_ds18b20(0xcc); //跳过ROM
		   write_byte_ds18b20(0xbe); //准备好数据（开始温度转换采集）
		   templ=read_byte_ds18b20();//读低字节温度值
		   temph=read_byte_ds18b20();//读低字节温度值
		   temp=(templ+(temph*256));
		   return(temp);
		}
		
		
		
		
		void delay_ds18b20(unsigned int time)
		{
		     uint  i,j;
			 for(i=0;i<time;i++)
				for(j=0;j<1;j++);
		}

