---
title: 定时器中断
date: 2020-08-04 12:03:04
tags:
- stm32
categories:
- 单片机
- stm32

---
# 一、定时器工作过程 #

![通用定时器工作过程](/images/单片机/stm32/定时器/通用定时器工作过程.png)

## 1、时钟选择 ##

**计数器时钟可以由下列时钟源提供：**

**内部时钟(CK_INT)**

**外部时钟模式1：外部输入脚(TIx)**

**外部时钟模式2：外部触发输入(ETR)**

**内部触发输入(ITRx)：使用一个定时器作为另一个定时器的预分频器，如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。**


## 2、内部时钟选择 ##

![内部时钟选择](/images/单片机/stm32/定时器/内部时钟选择.png)


![时钟计算](/images/单片机/stm32/定时器/时钟计算.png)


**除非APB1的分频系数是1，否则通用定时器的时钟等于APB1时钟的2倍。**


	默认调用SystemInit函数情况下：
	SYSCLK=72M
	AHB时钟=72M
	APB1时钟=36M
	所以APB1的分频系数=AHB/APB1时钟=2
	所以，通用定时器时钟CK_INT=2*36M=72M


## 3、计数器模式 ##
通用定时器可以**向上计数、向下计数、向上向下双向计数模式**。

- 向上计数模式：计数器从0计数到自动加载值(TIMx_ARR)，然后重新从0开始计数并且产生一个计数器溢出事件。

- 向下计数模式：计数器从自动装入的值(TIMx_ARR)开始向下计数到0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件。

- 中央对齐模式（向上/向下计数）：计数器从0开始计数到自动装入的值-1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器溢出事件；然后再从0开始重新计数。


## 4、向下计数模式（时钟分频因子=1） ##


![向下计数](/images/单片机/stm32/定时器/向下计数.png)





## 5、向上计数模式（时钟分频因子=1） ##


![向上计数](/images/单片机/stm32/定时器/向上计数.png)






## 6、中央对齐计数模式（时钟分频因子=1  ARR=6） ##


![中央对齐计数](/images/单片机/stm32/定时器/中央对齐计数.png)






# 二、寄存器说明 #



**计数器当前值寄存器CNT**

![TIMx_CNT](/images/单片机/stm32/定时器/TIMx_CNT.png)


**预分频寄存器TIMx_PSC**

![TIMx_PSC](/images/单片机/stm32/定时器/TIMx_PSC.png)


**自动重装载寄存器（TIMx_ARR)**

![TIMx_ARR](/images/单片机/stm32/定时器/TIMx_ARR.png)



**控制寄存器1（TIMx_CR1）**


![TIMx_CR1](/images/单片机/stm32/定时器/TIMx_CR1.png)


**DMA中断使能寄存器（TIMx_DIER）**


![TIMx_DIER](/images/单片机/stm32/定时器/TIMx_DIER.png)



# 三、常用库函数 #


## 1、定时器参数初始化： ##


> void TIM_TimeBaseInit(TIM_TypeDef* TIMx,TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);

	typedef struct
	{
	  uint16_t TIM_Prescaler;        
	  uint16_t TIM_CounterMode;     
	  uint16_t TIM_Period;        
	  uint16_t TIM_ClockDivision;  
	  uint8_t TIM_RepetitionCounter;
	} TIM_TimeBaseInitTypeDef; 
	
	
	TIM_TimeBaseStructure.TIM_Period = 4999; 
	TIM_TimeBaseStructure.TIM_Prescaler =7199; 
	TIM_TimeBaseStructure.TIM_ClockDivision =   TIM_CKD_DIV1; 
	TIM_TimeBaseStructure.TIM_CounterMode =   TIM_CounterMode_Up; 
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); 



## 2、定时器使能函数： ##

> void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)

## 3、定时器中断使能函数： ##

> void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);

## 4、状态标志位获取和清除 ##

> FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);

> void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);

> ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);

> void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);



# 四、定时器中断实现步骤 #


- 能定时器时钟。

       RCC_APB1PeriphClockCmd();

- 初始化定时器，配置ARR,PSC。

      TIM_TimeBaseInit();

- 开启定时器中断，配置NVIC。

      void TIM_ITConfig();
      NVIC_Init();

- 使能定时器。

      TIM_Cmd();

- 编写中断服务函数。

      TIMx_IRQHandler();


**Tout（溢出时间）=（ARR+1)(PSC+1)/Tclk**

# 五、代码: #



	void TIM3_Int_Init(u16 arr,u16 psc)
	{
	    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
		NVIC_InitTypeDef NVIC_InitStructure;
	
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); 
		TIM_TimeBaseStructure.TIM_Period = arr; 
		TIM_TimeBaseStructure.TIM_Prescaler =psc;   
		TIM_TimeBaseStructure.TIM_ClockDivision = 0; 
		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; 
		TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //定时器初始化
	 
		TIM_ITConfig(  //开启中断
			TIM3, //TIM2
			TIM_IT_Update ,
			ENABLE 
			);
		NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  
		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; 
		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; 
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
		NVIC_Init(&NVIC_InitStructure); //中断向量配置
	
		TIM_Cmd(TIM3, ENABLE);  
								 
	}
	
	void TIM3_IRQHandler(void)   //中断函数
	{
		if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) 
			{
			TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  
			LED1=!LED1;
			}
	}
	












