---
title: 汇编指令详解（逻辑运算类指令）
date: 2020-09-19 12:05:39
tags:
- 汇编
categories:
- 单片机
- 汇编语言

---


# 一、逻辑运算类指令 #


### 1.1、对累加器A的逻辑操作 ###

**CLR A ；将A中的值清0，单周期单字节指令，与MOV A，#00H效果相同。**

**CPL A ；将A中的值按位取反**

**RL A ；将A中的值逻辑左移**

**RLC A ；将A中的值加上进位位进行逻辑左移**

**RR A ；将A中的值进行逻辑右移**

**RRC A ；将A中的值加上进位位进行逻辑右移**

**SWAP A ；将A中的值高、低4位交换。**

 

**例**：（A）=73H，则执行CPL A，这样进行：

	73H化为二进制为01110011，
	
	逐位取反即为 10001100，也就是8CH。
	
	RL A是将（A）中的值的第7位送到第0位，第0位送1位，依次类推。

 

**例**：A中的值为68H，执行RL A。68H化为二进制为01101000，按上图进行移动。01101000化为11010000，即D0H。

RLC A，是将（A）中的值带上进位位（C）进行移位。

 

**例**：A中的值为68H，C中的值为1，则执行RLC A

1 01101000后，结果是0 11010001，也就是C进位位的值变成了0，而（A）则变成了D1H。

RR A和RRC A就不多谈了。

SWAP A，是将A中的值的高、低4位进行交换。

 

例：（A）=39H，则执行SWAP A之后，A中的值就是93H。怎么正好是这么前后交换呢？因为这是一个16进制数，每1个16进位数字代表4个二进位。注意，如果是这样的：（A）=39，后面没H，执行SWAP A之后，可不是（A）=93。要将它化成二进制再算：39化为二进制是10111，也就是0001，0111高4位是0001，低4位是0111，交换后是01110001，也就是71H，即113。

 
### 1.2、逻辑与指令 ###

**ANL              A,Rn        ;A与Rn中的值按位'与'，结果送入A中**

**ANL              A,direct ;A与direct中的值按位'与'，结果送入A中**

**ANL              A,@Ri ;A与间址寻址单元@Ri中的值按位'与'，结果送入A中**

**ANL              A,#data ;A与立即数data按位'与'，结果送入A中**

**ANL              direct,A ;direct中值与A中的值按位'与'，结果送入direct中**

**ANL              direct,#data ;direct中的值与立即数data按位'与'，结果送入direct中。**

 

这几条指令的关键是知道什么是逻辑与。**这里的逻辑与是指按位与**

例：71H和56H相与则将两数写成二进制形式：

（71H） 01110001

（56H） 00100110

结果 00100000 即20H，从上面的式子可以看出，两个参与运算的值只要其中有一个位上是0，则这位的结果就是0，两个同是1，结果才是1。

理解了逻辑与的运算规则，结果自然就出来了。看每条指令后面的注释

下面再举一些例子来看。

MOV              A，#45H ;(A)=45H

MOV              R1，#25H ;(R1)=25H

MOV              25H，#79H ;(25H)=79H

ANL              A，@R1 ;45H与79H按位与，结果送入A中为 41H （A）=41H

ANL              25H,#15H ;25H中的值（79H）与15H相与结果为（25H）=11H）

ANL              25H,A ;25H中的值（11H）与A中的值（41H)相与，结果为(25H)=11H

在知道了逻辑与指令的功能后，逻辑或和逻辑异或的功能就很简单了。逻辑或是按位“或”，即有“1”为1，全“0”为0。例：

10011000

或 01100001

结果 11111001

而异或则是按位“异或”，相同为“0”，相异为“1”。例：

10011000

异或 01100001

结果 11111001

而所有的或指令，就是将与指令中的ANL 换成ORL，而异或指令则是将ANL       换成XRL。

 　　　　

### 1.3、逻辑或指令 ###

**ORL              A,Rn        ;A和Rn中的值按位'或'，结果送入A中**

**ORL              A,direct ;A和与间址寻址单元@Ri中的值按位'或'，结果送入A中**

**ORL              A,#data ;A和立direct中的值按位'或'，结果送入A中**

**ORL              A,@Ri ;A和即数data按位'或'，结果送入A中**

**ORL              direct,A ;direct中值和A中的值按位'或'，结果送入direct中**

**ORL              direct,#data ;direct中的值和立即数data按位'或'，结果送入direct中。**

 
### 1.4、逻辑异或指令 ###

**XRL              A,Rn        ;A和Rn中的值按位'异或'，结果送入A中**

**XRL              A,direct ;A和direct中的值按位'异或'，结果送入A中**

**XRL              A,@Ri ;A和间址寻址单元@Ri中的值按位'异或'，结果送入A中**

**XRL              A,#data ;A和立即数data按位'异或'，结果送入A中**

**XRL              direct,A ;direct中值和A中的值按位'异或'，结果送入direct中**

**XRL              direct,#data ;direct中的值和立即数data按位'异或'，结果送入direct中。**